Week1
#1 Think broad, but do as specific as possible.
#2 Various thoughts on how AR and location-based technology can be implemented to help people.
#3 Various ideas on making changes to exitsitng app 
#4 Quality as seen by developers- Dissatisfiers, Satisfiers and Delighters.

Week2
#Worked on ideas to build project proposals.
#Continued thinking and working on ideas. Not getting ideas doesn't imply failure or as being non-creative/non-innovative.

Week3
#A software engineer needs to know programming, be able to design what his customer requires,follow a disciplined process to create a 
product and should know to do team work.
#Software engineering includes engineering, art, science, manufacturing etc.
# Discussed about the similarities between Movie Making and Software Engineering.
#Learnt about the principles of Software Engineering- Abstraction and Decomposition.
#Learnt about the different types of software - Generic and Custom Software.
#Try to solve essential problems and avoid accidental problems. 


#Week4
#Different terms related to the definition of Software Engineering were discussed- Multi-person and Multi version software, Fault-free
and systematic approach to design software.
#Lifecycle models for software were discussed- Traditional and agile. Traditional models are plan driven models whereas agile models 
involve tough deadlines to complete tasks.(Agile models not covered yet). Even though life cycle models are grouped, the basic outline 
for both the models is one and the same,i.e., software is designed, developed, tested and deployed.
#Examples of various  models are Scrum,Crystal Lean, XP, DSDM, RUP, PSP etc.
#Deming principle of PDCA- Plan do check and act was introduced.
#The gap between the problem world and solution world has to be bridged when a software is designed.
#While building a software for customer, design it keeping in mind the role of the customer and not the customer himself.
#Requirements engineering process was also discussed.
#Discussed abouth the requirements and stakeholders of Facebook and tried to represent this using a mathematical notation. I used propositional
logic to represent it.
#Many formal methods exist to represent these requirements. Finite automata is one of them. If formal methods were not used, then all the 
softwares would have 1 lac requirement lines as the Boeing aircraft. 


#Week5
#Iterative waterfall model, prototype model , evolutionary model and spiral model were discussed. Instances where each model can 
be used were pointed out.
#Agile processes was introduced. We debated the pros and cons of the agile manifesto. Agile manifesto talks about the preferences
that needs to be given so that the designed product can be cost effective,minimal and optimal effort and prioritized preferences.
#Learnt about the term 'Pair programming' and how much it is important for each developer to understand and test all the aspects
of a software product.
#Product quality and process should always be co-related while designing a product.
#Zachman Framework was discussed.
#Scrum, an agile model was discussed in detail. Each step involved in this model was explained.
#Learnt about user-stories as well (who,what and why).
#A product can be estimated in terms of the size, effort and resources needed to complete the product.
#Varoius estimation methodolgies include- Top Down, Bottom up, Expert judgement, Priced to win and Parametric/Algorithmic methods.  
#Barry Boehm's COCOMO (COnstructive COst MOdel) was discussed in brief. This model would take LOC as input and return person-months as output.
It is one of the estimation methods.

# Week6
#The topic of software design was introduced in the class.
#Design involves the transition from possible solutions to a specific one.
#Design involves analysis, synthesis and evaluation of goals,contraints,assumptions deciosin and ideas.
#Wireframes was discussed in class again. Balsamiq wireframe was given as an example.
#Software design can expressed using UI mockup, ER diagram and sequence diagram.
#Software design represents an abstracted form of the plan and modules required.
#Design tools decrease the burden of creating design atrifacts, increase the abitlity of interpreting design artifacts 
and sharability.
#Model-driven development was introduced in class.
#Software Design should be documented, modular, abstract and should be assessed for quality as well.
#Design modules should support maintenance and verification.

# Week 7
# Various profiles and characteristics of users was discussed. While designing apiece of software the developer must consider the level
of expertise that the users(in general) might have with regar dto software usage, how frequently the users will use the piece of software and their
capabilities and constraints.
# Various UI designs were discussed and few examples of bad designs were pointed out in the class.
# Natural user inteface was introduced this week.

# Week 8
# UML class diagrams, sequence diagrams were discussed again in the class.
# Pattern based design was introduced this week.
# Problem + Solution + Context= Leads to a pattern 
# 23 patterns have been observed in software engineering. These observations were made by "Gang of four". They also classified patterns
into creational patterns,structural patterns and beavioural patterns.
# Under the creational patterns, Factory and abstract factory models were discussed. These patterns try to provide an abstract form to
classes so that they can be used in general.
# Momento pattern was also discussed.

# Week 9
#Anti patterns was introduced. Lava flow,The blob, Refactoring was discussed.
#Brainstormed about the paper summary submitted-Big data for engineering solutions.
#Brainstromed about how Machine learning algorithms can be applied for code,requirement analysis etc.






